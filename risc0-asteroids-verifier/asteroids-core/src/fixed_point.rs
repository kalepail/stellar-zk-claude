use crate::constants::{WORLD_HEIGHT_Q12_4, WORLD_WIDTH_Q12_4};

const SIN_TABLE: [i16; 256] = [
    0, 402, 804, 1205, 1606, 2006, 2404, 2801, 3196, 3590, 3981, 4370, 4756, 5139, 5520, 5897,
    6270, 6639, 7005, 7366, 7723, 8076, 8423, 8765, 9102, 9434, 9760, 10080, 10394, 10702, 11003,
    11297, 11585, 11866, 12140, 12406, 12665, 12916, 13160, 13395, 13623, 13842, 14053, 14256,
    14449, 14635, 14811, 14978, 15137, 15286, 15426, 15557, 15679, 15791, 15893, 15986, 16069,
    16143, 16207, 16261, 16305, 16340, 16364, 16379, 16384, 16379, 16364, 16340, 16305, 16261,
    16207, 16143, 16069, 15986, 15893, 15791, 15679, 15557, 15426, 15286, 15137, 14978, 14811,
    14635, 14449, 14256, 14053, 13842, 13623, 13395, 13160, 12916, 12665, 12406, 12140, 11866,
    11585, 11297, 11003, 10702, 10394, 10080, 9760, 9434, 9102, 8765, 8423, 8076, 7723, 7366, 7005,
    6639, 6270, 5897, 5520, 5139, 4756, 4370, 3981, 3590, 3196, 2801, 2404, 2006, 1606, 1205, 804,
    402, 0, -402, -804, -1205, -1606, -2006, -2404, -2801, -3196, -3590, -3981, -4370, -4756,
    -5139, -5520, -5897, -6270, -6639, -7005, -7366, -7723, -8076, -8423, -8765, -9102, -9434,
    -9760, -10080, -10394, -10702, -11003, -11297, -11585, -11866, -12140, -12406, -12665, -12916,
    -13160, -13395, -13623, -13842, -14053, -14256, -14449, -14635, -14811, -14978, -15137, -15286,
    -15426, -15557, -15679, -15791, -15893, -15986, -16069, -16143, -16207, -16261, -16305, -16340,
    -16364, -16379, -16384, -16379, -16364, -16340, -16305, -16261, -16207, -16143, -16069, -15986,
    -15893, -15791, -15679, -15557, -15426, -15286, -15137, -14978, -14811, -14635, -14449, -14256,
    -14053, -13842, -13623, -13395, -13160, -12916, -12665, -12406, -12140, -11866, -11585, -11297,
    -11003, -10702, -10394, -10080, -9760, -9434, -9102, -8765, -8423, -8076, -7723, -7366, -7005,
    -6639, -6270, -5897, -5520, -5139, -4756, -4370, -3981, -3590, -3196, -2801, -2404, -2006,
    -1606, -1205, -804, -402,
];

const COS_TABLE: [i16; 256] = [
    16384, 16379, 16364, 16340, 16305, 16261, 16207, 16143, 16069, 15986, 15893, 15791, 15679,
    15557, 15426, 15286, 15137, 14978, 14811, 14635, 14449, 14256, 14053, 13842, 13623, 13395,
    13160, 12916, 12665, 12406, 12140, 11866, 11585, 11297, 11003, 10702, 10394, 10080, 9760, 9434,
    9102, 8765, 8423, 8076, 7723, 7366, 7005, 6639, 6270, 5897, 5520, 5139, 4756, 4370, 3981, 3590,
    3196, 2801, 2404, 2006, 1606, 1205, 804, 402, 0, -402, -804, -1205, -1606, -2006, -2404, -2801,
    -3196, -3590, -3981, -4370, -4756, -5139, -5520, -5897, -6270, -6639, -7005, -7366, -7723,
    -8076, -8423, -8765, -9102, -9434, -9760, -10080, -10394, -10702, -11003, -11297, -11585,
    -11866, -12140, -12406, -12665, -12916, -13160, -13395, -13623, -13842, -14053, -14256, -14449,
    -14635, -14811, -14978, -15137, -15286, -15426, -15557, -15679, -15791, -15893, -15986, -16069,
    -16143, -16207, -16261, -16305, -16340, -16364, -16379, -16384, -16379, -16364, -16340, -16305,
    -16261, -16207, -16143, -16069, -15986, -15893, -15791, -15679, -15557, -15426, -15286, -15137,
    -14978, -14811, -14635, -14449, -14256, -14053, -13842, -13623, -13395, -13160, -12916, -12665,
    -12406, -12140, -11866, -11585, -11297, -11003, -10702, -10394, -10080, -9760, -9434, -9102,
    -8765, -8423, -8076, -7723, -7366, -7005, -6639, -6270, -5897, -5520, -5139, -4756, -4370,
    -3981, -3590, -3196, -2801, -2404, -2006, -1606, -1205, -804, -402, 0, 402, 804, 1205, 1606,
    2006, 2404, 2801, 3196, 3590, 3981, 4370, 4756, 5139, 5520, 5897, 6270, 6639, 7005, 7366, 7723,
    8076, 8423, 8765, 9102, 9434, 9760, 10080, 10394, 10702, 11003, 11297, 11585, 11866, 12140,
    12406, 12665, 12916, 13160, 13395, 13623, 13842, 14053, 14256, 14449, 14635, 14811, 14978,
    15137, 15286, 15426, 15557, 15679, 15791, 15893, 15986, 16069, 16143, 16207, 16261, 16305,
    16340, 16364, 16379,
];

const ATAN_TABLE: [u8; 33] = [
    0, 1, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 25, 26, 27,
    28, 29, 29, 30, 31, 31, 32,
];

#[inline]
pub fn to_q12_4(value: i32) -> i32 {
    value * 16
}

#[inline]
pub fn sin_bam(angle: i32) -> i32 {
    SIN_TABLE[(angle & 0xff) as usize] as i32
}

#[inline]
pub fn cos_bam(angle: i32) -> i32 {
    COS_TABLE[(angle & 0xff) as usize] as i32
}

#[inline]
pub fn displace_q12_4(angle: i32, dist_pixels: i32) -> (i32, i32) {
    (
        (cos_bam(angle) * dist_pixels) >> 10,
        (sin_bam(angle) * dist_pixels) >> 10,
    )
}

#[inline]
pub fn velocity_q8_8(angle: i32, speed_q8_8: i32) -> (i32, i32) {
    (
        (cos_bam(angle) * speed_q8_8) >> 14,
        (sin_bam(angle) * speed_q8_8) >> 14,
    )
}

#[inline]
pub fn apply_drag(v: i32) -> i32 {
    v - (v >> 7)
}

pub fn clamp_speed_q8_8(mut vx: i32, mut vy: i32, max_sq_q16_16: i32) -> (i32, i32) {
    // Kept in i32 for RV32 guest performance. This stays safe because vx/vy are
    // tightly bounded by the game physics and clamping rules.
    let max = max_sq_q16_16;
    let mut speed_sq = (vx * vx) + (vy * vy);

    if speed_sq <= max {
        return (vx, vy);
    }

    while speed_sq > max {
        vx = (vx * 3) >> 2;
        vy = (vy * 3) >> 2;
        speed_sq = (vx * vx) + (vy * vy);
    }

    (vx, vy)
}

#[inline]
pub fn wrap_x_q12_4(x: i32) -> i32 {
    if x < 0 {
        x + WORLD_WIDTH_Q12_4
    } else if x >= WORLD_WIDTH_Q12_4 {
        x - WORLD_WIDTH_Q12_4
    } else {
        x
    }
}

#[inline]
pub fn wrap_y_q12_4(y: i32) -> i32 {
    if y < 0 {
        y + WORLD_HEIGHT_Q12_4
    } else if y >= WORLD_HEIGHT_Q12_4 {
        y - WORLD_HEIGHT_Q12_4
    } else {
        y
    }
}

#[inline]
pub fn clamp_i32(value: i32, min: i32, max: i32) -> i32 {
    if value < min {
        min
    } else if value > max {
        max
    } else {
        value
    }
}

#[inline]
pub fn shortest_delta_q12_4(from: i32, to: i32, size: i32) -> i32 {
    let mut delta = to - from;
    let half = size >> 1;

    if delta > half {
        delta -= size;
    } else if delta < -half {
        delta += size;
    }

    delta
}

#[inline]
pub fn collision_dist_sq_q12_4(ax: i32, ay: i32, bx: i32, by: i32) -> i32 {
    let dx = shortest_delta_q12_4(ax, bx, WORLD_WIDTH_Q12_4);
    let dy = shortest_delta_q12_4(ay, by, WORLD_HEIGHT_Q12_4);
    dx * dx + dy * dy
}

pub fn atan2_bam(dy: i32, dx: i32) -> i32 {
    if dx == 0 && dy == 0 {
        return 0;
    }

    let abs_dx = dx.abs();
    let abs_dy = dy.abs();

    let (mut ratio, swapped) = if abs_dx >= abs_dy {
        (
            if abs_dx == 0 {
                0
            } else {
                (abs_dy * 32) / abs_dx
            },
            false,
        )
    } else {
        (
            if abs_dy == 0 {
                0
            } else {
                (abs_dx * 32) / abs_dy
            },
            true,
        )
    };

    if ratio > 32 {
        ratio = 32;
    }

    let mut angle = ATAN_TABLE[ratio as usize] as i32;

    if swapped {
        angle = 64 - angle;
    }
    if dx < 0 {
        angle = 128 - angle;
    }
    if dy < 0 {
        angle = (256 - angle) & 0xff;
    }

    angle & 0xff
}
